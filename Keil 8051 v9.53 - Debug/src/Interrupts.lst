C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/07/2016 11:45:03 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE INTERRUPTS
OBJECT MODULE PLACED IN .\src\Interrupts.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v3\developer\toolchains\keil_8051\9.53\BIN\C51.exe C:\Users\clfilho
                    -\Dropbox (Silicon Labs)\Code_Workspace\EFM8UB1_Timer0_8bitReload\src\Interrupts.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARG
                    -E) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:\Users\clfilho\
                    -Dropbox (Silicon Labs)\Code_Workspace\EFM8UB1_Timer0_8bitReload\inc;C:/SiliconLabs/SimplicityStudio/v3/developer/sdks/si
                    -8051/v3//Device/shared/si8051Base;C:/SiliconLabs/SimplicityStudio/v3/developer/sdks/si8051/v3//Device/EFM8UB1;C:/Silicon
                    -Labs/SimplicityStudio/v3/developer/sdks/si8051/v3//Device/EFM8UB1/inc) PRINT(.\src\Interrupts.lst) COND PAGEWIDTH(120) P
                    -AGELENGTH(65) OBJECT(.\src\Interrupts.OBJ)

line level    source

   1          //=========================================================
   2          // src/Interrupts.c: generated by Hardware Configurator
   3          //
   4          // This file will be regenerated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!
   7          //=========================================================
   8          
   9                   
  10          // USER INCLUDES                        
  11          #include <SI_EFM8UB1_Register_Enums.h>
  12          #include "InitDevice.h"
  13          #include "Dali.h"
  14          
  15          //extern bit MDone;
  16          //extern bit MOutput;
  17          
  18          //-----------------------------------------------------------------------------
  19          // Global Constants
  20          //-----------------------------------------------------------------------------
  21          // Configurator set for HFOSC0/8
  22          #define SYSCLK             3062000
  23          
  24          static xdata DALI_TXFRAME State = START;
  25          static xdata uint8_t bitCounter = 0;
  26          static xdata uint8_t daliRXOutput=0;
  27          bit _1stHalf;
  28          bit _2ndHalf;
  29          
  30          SI_SBIT (LED2,SFR_P1, 4);                          //PB0 Switch Definition
  31          
  32          //-----------------------------------------------------------------------------
  33          // TIMER1_ISR
  34          //-----------------------------------------------------------------------------
  35          //
  36          // TIMER1 ISR Content goes here. Remember to clear flag bits:
  37          // TCON::TF1 (Timer 0 Overflow Flag)
  38          //
  39          // Here we process the Timer dedicated to Dali RX
  40          //
  41          //-----------------------------------------------------------------------------
  42          SI_INTERRUPT (TIMER1_ISR, TIMER1_IRQn)
  43          {
  44   1      
  45   1      
  46   1      static xdata uint8_t counter = 0;
  47   1      xdata uint8_t buffer[8];
  48   1      xdata uint8_t BitBuffer[32];
  49   1      static xdata uint8_t Bunter=0;
  50   1      
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/07/2016 11:45:03 PAGE 2   

  51   1                      ReloadDaliTxTimer(TMH, TML);
  52   1      
  53   1              switch (State)
  54   1      
  55   1                      {
  56   2      
  57   2                              case START:                     //In this state, it checks if the RX bus was quite and also if it receives the start bit
  58   2                                              {
  59   3                                                      break;
  60   3                                              }
  61   2      
  62   2                              case DATA:
  63   2                                              {
  64   3      
  65   3                                                      if(counter==0)
  66   3                                                      {
  67   4                                                              LED2^=1;
  68   4                                                              _1stHalf=GetDaliIntputPin();
  69   4                                                              BitBuffer[Bunter++] = _1stHalf;
  70   4      
  71   4                                                      }
  72   3      
  73   3      
  74   3                                                      if (counter++==1)
  75   3                                                      {       LED2^=1;
  76   4                                                              _2ndHalf=GetDaliIntputPin();
  77   4                                                              BitBuffer[Bunter++] = _2ndHalf;
  78   4      #if 0
                                                                      if ((_1stHalf==0) && (_2ndHalf==1))                     // Logic 1 received
                                                                      {
                                                                              daliRXOutput = bitCounter<<1;
                                                                      }
                                                                      else if ((_1stHalf==1) && (_2ndHalf==0))        // Logic 0 received
                                                                      {
                                                                              daliRXOutput = bitCounter<<0;
                                                                      }
                                                                      else if (_1stHalf ==_2ndHalf)                           // Corrupted bit received
                                                                      {
                                                                              EnableInt1();
                                                                              State = START;
                                                                      }
              #endif
  93   4                                                              counter=0;
  94   4                                                      }
  95   3      
  96   3                                                      buffer[bitCounter] = daliRXOutput;
  97   3      
  98   3                                                      //if (bitCounter--==0)                                                  //Last bit was received
  99   3                                                      if (Bunter==31)
 100   3                                                      {
 101   4                                                              Bunter=0;
 102   4                                                              EnableInt1();
 103   4                                                              State = START;
 104   4                                                      }
 105   3      
 106   3                                                      break;
 107   3                                              }
 108   2      
 109   2                      }
 110   1      
 111   1      
 112   1      }
 113          
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/07/2016 11:45:03 PAGE 3   

 114          
 115          //-----------------------------------------------------------------------------
 116          // TIMER0_ISR
 117          //-----------------------------------------------------------------------------
 118          //
 119          // TIMER0 ISR Content goes here. Remember to clear flag bits:
 120          // TCON::TF0 (Timer 0 Overflow Flag)
 121          //
 122          // Here we process the Timer0 interrupt and toggle the LED when appropriate
 123          //
 124          //-----------------------------------------------------------------------------
 125          SI_INTERRUPT (TIMER0_ISR, TIMER0_IRQn)
 126          {
 127   1         static xdata uint8_t counter = 0;
 128   1         xdata uint8_t buffer[8];
 129   1         xdata uint8_t BitBuffer[32];
 130   1         static xdata uint8_t Bunter=0;
 131   1      
 132   1      
 133   1              ReloadDaliTxTimer(TMH, TML);
 134   1              DaliTxHandler();
 135   1              QueryDaliBus();
 136   1      
 137   1      #if 0
                      switch (State)
              
                              {
              
                                      case START:                     //In this state, it checks if the RX bus was quite and also if it receives the start bit
                                                      {
                                                              break;
                                                      }
              
                                      case DATA:
                                                      {
              
                                                              if(counter==0)
                                                              {
                                                                      LED2^=1;
                                                                      _1stHalf=GetDaliIntputPin();
                                                                      BitBuffer[Bunter++] = _1stHalf;
              
                                                              }
              
              
                                                              if (counter++==1)
                                                              {       LED2^=1;
                                                                      _2ndHalf=GetDaliIntputPin();
                                                                      BitBuffer[Bunter++] = _2ndHalf;
              #if 0
                                                                      if ((_1stHalf==0) && (_2ndHalf==1))                     // Logic 1 received
                                                                      {
                                                                              daliRXOutput = bitCounter<<1;
                                                                      }
                                                                      else if ((_1stHalf==1) && (_2ndHalf==0))        // Logic 0 received
                                                                      {
                                                                              daliRXOutput = bitCounter<<0;
                                                                      }
                                                                      else if (_1stHalf ==_2ndHalf)                           // Corrupted bit received
                                                                      {
                                                                              EnableInt1();
                                                                              State = START;
                                                                      }
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/07/2016 11:45:03 PAGE 4   

              #endif
                                                                      counter=0;
                                                              }
              
                                                              buffer[bitCounter] = daliRXOutput;
              
                                                              //if (bitCounter--==0)                                                  //Last bit was received
                                                              if (Bunter==31)
                                                              {
                                                                      Bunter=0;
                                                                      EnableInt1();
                                                                      State = START;
                                                              }
              
                                                              break;
                                                      }
              
                              }
              
              #endif
 197   1      
 198   1      }
*** WARNING C280 IN LINE 127 OF C:\Users\clfilho\Dropbox (Silicon Labs)\Code_Workspace\EFM8UB1_Timer0_8bitReload\src\Int
             -errupts.c: 'counter': unreferenced local variable
*** WARNING C280 IN LINE 128 OF C:\Users\clfilho\Dropbox (Silicon Labs)\Code_Workspace\EFM8UB1_Timer0_8bitReload\src\Int
             -errupts.c: 'buffer': unreferenced local variable
*** WARNING C280 IN LINE 129 OF C:\Users\clfilho\Dropbox (Silicon Labs)\Code_Workspace\EFM8UB1_Timer0_8bitReload\src\Int
             -errupts.c: 'BitBuffer': unreferenced local variable
*** WARNING C280 IN LINE 130 OF C:\Users\clfilho\Dropbox (Silicon Labs)\Code_Workspace\EFM8UB1_Timer0_8bitReload\src\Int
             -errupts.c: 'Bunter': unreferenced local variable
 199          
 200          
 201          
 202          //-----------------------------------------------------------------------------
 203          // INT0_ISR
 204          //-----------------------------------------------------------------------------
 205          //
 206          // TIMER0 ISR Content goes here. Remember to clear flag bits:
 207          // TCON::TF0 (Timer 0 Overflow Flag)
 208          //
 209          // Here we process the Timer0 interrupt and toggle the LED when appropriate
 210          //
 211          //-----------------------------------------------------------------------------
 212          SI_INTERRUPT (INT1_ISR, INT1_IRQn)
 213          {
 214   1         static xdata uint8_t counter = 0;
 215   1      
 216   1      
 217   1         xdata uint16_t timerRead;
 218   1      
 219   1      
 220   1      
 221   1         //Reload Timer
 222   1      
 223   1      
 224   1      #if 1
 225   1      
 226   1              if((GetBusQuietCounter()>3)&&(GetDaliIntputPin()==0) &&(counter==0))
 227   1              {
 228   2                      timerRead = GetDaliRxTimer();
 229   2                      StartDaliRxTimer();
 230   2                      _1stHalf=GetDaliIntputPin();
 231   2                      SetDaliInputPinPolarity(ACTIVE_HIGH);
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/07/2016 11:45:03 PAGE 5   

 232   2              }
 233   1      
 234   1      
 235   1              if (counter++==1)
 236   1              {
 237   2                      _2ndHalf=GetDaliIntputPin();
 238   2                      SetDaliInputPinPolarity(ACTIVE_LOW);
 239   2                      timerRead = GetDaliRxTimer();
 240   2                      //State = DATA;
 241   2                      //counter=0;
 242   2              }
 243   1      
 244   1              if ((_1stHalf==0) && (_2ndHalf==1))                     // Start bit received
 245   1              {
 246   2                      DisableInt1 ();
 247   2                      ReloadDaliTxTimer(TMH, TML);
 248   2                      bitCounter=7;
 249   2                      daliRXOutput=0;
 250   2                      State = DATA;
 251   2                      counter=0;
 252   2                      _1stHalf = _2ndHalf =0;
 253   2                      StopDaliRxTimer();
 254   2      
 255   2              }
 256   1              else if (counter==2)
 257   1              {
 258   2                      counter=0;
 259   2                      _1stHalf = _2ndHalf =0;
 260   2              }
 261   1      
 262   1      #else
              
              
              
                      switch (State)
              
                      {
              
                              case START:                     //In this state, it checks if the RX bus was quit and also if it receives the start bit
                                              {
                                                      if((GetBusQuietCounter()>3)&&(GetDaliIntputPin()==0) &&(counter==0))
                                                      {
                                                              timerRead = GetDaliRxTimer();
                                                              StartDaliRxTimer();
                                                              _1stHalf=GetDaliIntputPin();
                                                              SetDaliInputPinPolarity(ACTIVE_HIGH);
                                                      }
              
              
                                                      if (counter++==1)
                                                      {
                                                              _2ndHalf=GetDaliIntputPin();
                                                              SetDaliInputPinPolarity(ACTIVE_LOW);
                                                              timerRead = GetDaliRxTimer();
                                                              //State = DATA;
                                                              //counter=0;
                                                      }
              
                                                      if ((_1stHalf==0) && (_2ndHalf==1))                     // Start bit received
                                                      {
                                                              DisableInt1 ();
                                                              ReloadDaliTxTimer();
                                                              State = DATA;
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/07/2016 11:45:03 PAGE 6   

                                                              counter=0;
                                                              _1stHalf = _2ndHalf =0;
                                                              StopDaliRxTimer();
              
                                                      }
                                                      else if (counter==2)
                                                      {
                                                              counter=0;
                                                              _1stHalf = _2ndHalf =0;
                                                      }
              
                                                      break;
              
                                              }
              
                              case DATA:
                                              {
              
              #if 0
                                                      if(counter==0)
                                                      {
                                                              timerRead = GetDaliRxTimer();
                                                              StartDaliRxTimer();
                                                              _1stHalf=GetDaliIntputPin();
                                                              if (_1stHalf==1)
                                                              SetDaliInputPinPolarity(ACTIVE_HIGH);
                                                      }
              
              
                                                      if (counter++==1)
                                                      {
                                                              _2ndHalf=GetDaliIntputPin();
                                                              SetDaliInputPinPolarity(ACTIVE_LOW);
                                                              timerRead = GetDaliRxTimer();
                                                              //State = DATA;
                                                              //counter=0;
                                                      }
              
              
              #else
                                                      State = START;
                                                      break;
              #endif
              
              
                      }
              
                      }
              #endif
 344   1      
 345   1      
 346   1      
 347   1      
 348   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    469    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      8      82
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/07/2016 11:45:03 PAGE 7   

   BIT SIZE         =      2    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)
