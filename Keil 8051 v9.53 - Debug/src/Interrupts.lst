C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/07/2016 15:59:08 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE INTERRUPTS
OBJECT MODULE PLACED IN .\src\Interrupts.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v3\developer\toolchains\keil_8051\9.53\BIN\C51.exe C:\Users\clfilho
                    -\Dropbox (Silicon Labs)\Code_Workspace\EFM8UB1_Timer0_8bitReload\src\Interrupts.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARG
                    -E) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:\Users\clfilho\
                    -Dropbox (Silicon Labs)\Code_Workspace\EFM8UB1_Timer0_8bitReload\inc;C:/SiliconLabs/SimplicityStudio/v3/developer/sdks/si
                    -8051/v3//Device/shared/si8051Base;C:/SiliconLabs/SimplicityStudio/v3/developer/sdks/si8051/v3//Device/EFM8UB1;C:/Silicon
                    -Labs/SimplicityStudio/v3/developer/sdks/si8051/v3//Device/EFM8UB1/inc) PRINT(.\src\Interrupts.lst) COND PAGEWIDTH(120) P
                    -AGELENGTH(65) OBJECT(.\src\Interrupts.OBJ)

line level    source

   1          //=========================================================
   2          // src/Interrupts.c: generated by Hardware Configurator
   3          //
   4          // This file will be regenerated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!
   7          //=========================================================
   8          
   9                   
  10          // USER INCLUDES                        
  11          #include <SI_EFM8UB1_Register_Enums.h>
  12          #include "InitDevice.h"
  13          #include "Dali.h"
  14          
  15          //extern bit MDone;
  16          //extern bit MOutput;
  17          
  18          //-----------------------------------------------------------------------------
  19          // Global Constants
  20          //-----------------------------------------------------------------------------
  21          // Configurator set for HFOSC0/8
  22          #define SYSCLK             3062000
  23          
  24          static xdata DALI_TXFRAME State = START;
  25          static xdata uint8_t bitCounter = 0;
  26          static xdata uint8_t daliRXOutput=0;
  27          bit _1stHalf;
  28          bit _2ndHalf;
  29          
  30          SI_SBIT (LED2,SFR_P1, 4);                          //PB0 Switch Definition
  31          
  32          //-----------------------------------------------------------------------------
  33          // TIMER1_ISR
  34          //-----------------------------------------------------------------------------
  35          //
  36          // TIMER1 ISR Content goes here. Remember to clear flag bits:
  37          // TCON::TF1 (Timer 0 Overflow Flag)
  38          //
  39          // Here we process the Timer dedicated to Dali RX
  40          //
  41          //-----------------------------------------------------------------------------
  42          SI_INTERRUPT (TIMER1_ISR, TIMER1_IRQn)
  43          {
  44   1      
  45   1      
  46   1      static xdata uint8_t counter = 0;
  47   1      xdata uint8_t buffer[8];
  48   1      xdata uint8_t BitBuffer[72];
  49   1      static xdata uint8_t Bunter=0;
  50   1      
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/07/2016 15:59:08 PAGE 2   

  51   1              ReloadDaliRxTimer(STMH, STML);
  52   1      //      LED2^=1;
  53   1      
  54   1              switch (State)
  55   1      
  56   1                      {
  57   2      
  58   2                              case START:                     //In this state, it checks if the RX bus was quite and also if it receives the start bit
  59   2                                              {
  60   3                                                      break;
  61   3                                              }
  62   2      
  63   2                              case DATA:
  64   2                                              {
  65   3      #if 0
                                                              if(counter==0)
                                                              {
                                                                      LED2^=1;
                                                                      _1stHalf=GetDaliIntputPin();
                                                                      BitBuffer[Bunter++] = _1stHalf;
              
                                                              }
              
              
                                                              if (counter++==1)
                                                              {       LED2^=1;
                                                                      _2ndHalf=GetDaliIntputPin();
                                                                      BitBuffer[Bunter++] = _2ndHalf;
              
                                                                      if ((_1stHalf==0) && (_2ndHalf==1))                     // Logic 1 received
                                                                      {
                                                                              daliRXOutput = bitCounter<<1;
                                                                      }
                                                                      else if ((_1stHalf==1) && (_2ndHalf==0))        // Logic 0 received
                                                                      {
                                                                              daliRXOutput = bitCounter<<0;
                                                                      }
                                                                      else if (_1stHalf ==_2ndHalf)                           // Corrupted bit received
                                                                      {
                                                                              EnableInt1();
                                                                              State = START;
                                                                      }
              
                                                                      counter=0;
                                                              }
              #endif
  97   3                                                      //buffer[bitCounter] = daliRXOutput;
  98   3                                                      LED2^=1;
  99   3                                                      BitBuffer[Bunter++] = GetDaliIntputPin();
 100   3                                                      //if (bitCounter--==0)                                                  //Last bit was received
 101   3                                                      if (Bunter==72)
 102   3                                                      {
 103   4                                                              Bunter=0;
 104   4                                                              EnableInt1();
 105   4                                                              State = START;
 106   4                                                      }
 107   3      
 108   3                                                      break;
 109   3                                              }
 110   2      
 111   2                      }
 112   1      
 113   1      
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/07/2016 15:59:08 PAGE 3   

 114   1      }
*** WARNING C280 IN LINE 46 OF C:\Users\clfilho\Dropbox (Silicon Labs)\Code_Workspace\EFM8UB1_Timer0_8bitReload\src\Inte
             -rrupts.c: 'counter': unreferenced local variable
*** WARNING C280 IN LINE 47 OF C:\Users\clfilho\Dropbox (Silicon Labs)\Code_Workspace\EFM8UB1_Timer0_8bitReload\src\Inte
             -rrupts.c: 'buffer': unreferenced local variable
 115          
 116          
 117          //-----------------------------------------------------------------------------
 118          // TIMER0_ISR
 119          //-----------------------------------------------------------------------------
 120          //
 121          // TIMER0 ISR Content goes here. Remember to clear flag bits:
 122          // TCON::TF0 (Timer 0 Overflow Flag)
 123          //
 124          // Here we process the Timer0 interrupt and toggle the LED when appropriate
 125          //
 126          //-----------------------------------------------------------------------------
 127          SI_INTERRUPT (TIMER0_ISR, TIMER0_IRQn)
 128          {
 129   1      
 130   1              ReloadDaliTxTimer(TMH, TML);
 131   1              DaliTxHandler();
 132   1              QueryDaliBus();
 133   1      
 134   1      }
 135          
 136          
 137          
 138          //-----------------------------------------------------------------------------
 139          // INT1_ISR
 140          //-----------------------------------------------------------------------------
 141          //
 142          // TIMER0 ISR Content goes here. Remember to clear flag bits:
 143          // TCON::TF0 (Timer 0 Overflow Flag)
 144          //
 145          // Here we process the Timer0 interrupt and toggle the LED when appropriate
 146          //
 147          //-----------------------------------------------------------------------------
 148          SI_INTERRUPT (INT1_ISR, INT1_IRQn)
 149          {
 150   1         static xdata uint8_t counter = 0;
 151   1      
 152   1      
 153   1         xdata uint16_t timerRead;
 154   1      
 155   1         timerRead = GetDaliRxTimer();
 156   1      
 157   1              if((GetBusQuietCounter()>3)&&(GetDaliIntputPin()==0) &&(counter==0))
 158   1              {
 159   2                      DisableDaliRxTimerInt();
 160   2                      ReloadDaliRxTimer(0,0);
 161   2                      StartDaliRxTimer();
 162   2                      _1stHalf=GetDaliIntputPin();
 163   2                      SetDaliInputPinPolarity(ACTIVE_HIGH);
 164   2              }
 165   1      
 166   1      
 167   1              if ((counter++==1) && (timerRead>200)&&(timerRead<230))
 168   1              {
 169   2      
 170   2                      _2ndHalf=GetDaliIntputPin();
 171   2                      SetDaliInputPinPolarity(ACTIVE_LOW);
 172   2      
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/07/2016 15:59:08 PAGE 4   

 173   2              }
 174   1      
 175   1              else
 176   1              {
 177   2                      SetDaliInputPinPolarity(ACTIVE_LOW);
 178   2              }
 179   1      
 180   1      
 181   1      
 182   1              if ((_1stHalf==0) && (_2ndHalf==1))                     // Start bit received
 183   1              {
 184   2                      DisableInt1 ();
 185   2                      StopDaliRxTimer();
 186   2      
 187   2                      //It will reload a one period worth of time, so it will start sampling on the next bit
 188   2                      ReloadDaliRxTimer(TMH, TML);
 189   2                      StartDaliRxTimer();
 190   2                      EnableDaliRxTimerInt();
 191   2                      bitCounter=7;
 192   2                      daliRXOutput=0;
 193   2                      State = DATA;
 194   2                      counter=0;
 195   2                      _1stHalf = _2ndHalf =0;
 196   2                      //
 197   2      
 198   2              }
 199   1              else if (counter==2)
 200   1              {
 201   2                      counter=0;
 202   2                      _1stHalf = _2ndHalf =0;
 203   2              }
 204   1      
 205   1      
 206   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    410    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      6      82
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
