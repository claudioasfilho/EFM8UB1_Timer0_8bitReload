C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/07/2016 11:34:26 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE INTERRUPTS
OBJECT MODULE PLACED IN .\src\Interrupts.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v3\developer\toolchains\keil_8051\9.53\BIN\C51.exe C:\Users\clfilho
                    -\Dropbox (Silicon Labs)\Code_Workspace\EFM8UB1_Timer0_8bitReload\src\Interrupts.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARG
                    -E) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:\Users\clfilho\
                    -Dropbox (Silicon Labs)\Code_Workspace\EFM8UB1_Timer0_8bitReload\inc;C:/SiliconLabs/SimplicityStudio/v3/developer/sdks/si
                    -8051/v3//Device/shared/si8051Base;C:/SiliconLabs/SimplicityStudio/v3/developer/sdks/si8051/v3//Device/EFM8UB1;C:/Silicon
                    -Labs/SimplicityStudio/v3/developer/sdks/si8051/v3//Device/EFM8UB1/inc) PRINT(.\src\Interrupts.lst) COND PAGEWIDTH(120) P
                    -AGELENGTH(65) OBJECT(.\src\Interrupts.OBJ)

line level    source

   1          //=========================================================
   2          // src/Interrupts.c: generated by Hardware Configurator
   3          //
   4          // This file will be regenerated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!
   7          //=========================================================
   8          
   9                   
  10          // USER INCLUDES                        
  11          #include <SI_EFM8UB1_Register_Enums.h>
  12          #include "InitDevice.h"
  13          
  14          //extern bit MDone;
  15          //extern bit MOutput;
  16          
  17          //-----------------------------------------------------------------------------
  18          // Global Constants
  19          //-----------------------------------------------------------------------------
  20          // Configurator set for HFOSC0/8
  21          #define SYSCLK             3062000
  22          
  23          static xdata DALI_TXFRAME State = START;
  24          static xdata uint8_t bitCounter = 0;
  25          static xdata uint8_t daliRXOutput=0;
  26          bit _1stHalf;
  27          bit _2ndHalf;
  28          
  29          SI_SBIT (LED2,SFR_P1, 4);                          //PB0 Switch Definition
  30          
  31          //-----------------------------------------------------------------------------
  32          // TIMER1_ISR
  33          //-----------------------------------------------------------------------------
  34          //
  35          // TIMER1 ISR Content goes here. Remember to clear flag bits:
  36          // TCON::TF1 (Timer 0 Overflow Flag)
  37          //
  38          // Here we process the Timer dedicated to Dali RX
  39          //
  40          //-----------------------------------------------------------------------------
  41          SI_INTERRUPT (TIMER1_ISR, TIMER1_IRQn)
  42          {
  43   1      
  44   1      
  45   1      static xdata uint8_t counter = 0;
  46   1      xdata uint8_t buffer[8];
  47   1      xdata uint8_t BitBuffer[32];
  48   1      static xdata uint8_t Bunter=0;
  49   1      
  50   1                      ReloadDaliTxTimer(TMH, TML);
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/07/2016 11:34:26 PAGE 2   

  51   1      
  52   1              switch (State)
  53   1      
  54   1                      {
  55   2      
  56   2                              case START:                     //In this state, it checks if the RX bus was quite and also if it receives the start bit
  57   2                                              {
  58   3                                                      break;
  59   3                                              }
  60   2      
  61   2                              case DATA:
  62   2                                              {
  63   3      
  64   3                                                      if(counter==0)
  65   3                                                      {
  66   4                                                              LED2^=1;
  67   4                                                              _1stHalf=GetDaliIntputPin();
  68   4                                                              BitBuffer[Bunter++] = _1stHalf;
  69   4      
  70   4                                                      }
  71   3      
  72   3      
  73   3                                                      if (counter++==1)
  74   3                                                      {       LED2^=1;
  75   4                                                              _2ndHalf=GetDaliIntputPin();
  76   4                                                              BitBuffer[Bunter++] = _2ndHalf;
  77   4      #if 0
                                                                      if ((_1stHalf==0) && (_2ndHalf==1))                     // Logic 1 received
                                                                      {
                                                                              daliRXOutput = bitCounter<<1;
                                                                      }
                                                                      else if ((_1stHalf==1) && (_2ndHalf==0))        // Logic 0 received
                                                                      {
                                                                              daliRXOutput = bitCounter<<0;
                                                                      }
                                                                      else if (_1stHalf ==_2ndHalf)                           // Corrupted bit received
                                                                      {
                                                                              EnableInt1();
                                                                              State = START;
                                                                      }
              #endif
  92   4                                                              counter=0;
  93   4                                                      }
  94   3      
  95   3                                                      buffer[bitCounter] = daliRXOutput;
  96   3      
  97   3                                                      //if (bitCounter--==0)                                                  //Last bit was received
  98   3                                                      if (Bunter==31)
  99   3                                                      {
 100   4                                                              Bunter=0;
 101   4                                                              EnableInt1();
 102   4                                                              State = START;
 103   4                                                      }
 104   3      
 105   3                                                      break;
 106   3                                              }
 107   2      
 108   2                      }
 109   1      
 110   1      
 111   1      }
 112          
 113          
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/07/2016 11:34:26 PAGE 3   

 114          //-----------------------------------------------------------------------------
 115          // TIMER0_ISR
 116          //-----------------------------------------------------------------------------
 117          //
 118          // TIMER0 ISR Content goes here. Remember to clear flag bits:
 119          // TCON::TF0 (Timer 0 Overflow Flag)
 120          //
 121          // Here we process the Timer0 interrupt and toggle the LED when appropriate
 122          //
 123          //-----------------------------------------------------------------------------
 124          SI_INTERRUPT (TIMER0_ISR, TIMER0_IRQn)
 125          {
 126   1         static xdata uint8_t counter = 0;
 127   1         xdata uint8_t buffer[8];
 128   1         xdata uint8_t BitBuffer[32];
 129   1         static xdata uint8_t Bunter=0;
 130   1      
 131   1      
 132   1              ReloadDaliTxTimer(TMH, TML);
 133   1              DaliTxHandler();
 134   1              QueryDaliBus();
 135   1      
 136   1      #if 0
                      switch (State)
              
                              {
              
                                      case START:                     //In this state, it checks if the RX bus was quite and also if it receives the start bit
                                                      {
                                                              break;
                                                      }
              
                                      case DATA:
                                                      {
              
                                                              if(counter==0)
                                                              {
                                                                      LED2^=1;
                                                                      _1stHalf=GetDaliIntputPin();
                                                                      BitBuffer[Bunter++] = _1stHalf;
              
                                                              }
              
              
                                                              if (counter++==1)
                                                              {       LED2^=1;
                                                                      _2ndHalf=GetDaliIntputPin();
                                                                      BitBuffer[Bunter++] = _2ndHalf;
              #if 0
                                                                      if ((_1stHalf==0) && (_2ndHalf==1))                     // Logic 1 received
                                                                      {
                                                                              daliRXOutput = bitCounter<<1;
                                                                      }
                                                                      else if ((_1stHalf==1) && (_2ndHalf==0))        // Logic 0 received
                                                                      {
                                                                              daliRXOutput = bitCounter<<0;
                                                                      }
                                                                      else if (_1stHalf ==_2ndHalf)                           // Corrupted bit received
                                                                      {
                                                                              EnableInt1();
                                                                              State = START;
                                                                      }
              #endif
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/07/2016 11:34:26 PAGE 4   

                                                                      counter=0;
                                                              }
              
                                                              buffer[bitCounter] = daliRXOutput;
              
                                                              //if (bitCounter--==0)                                                  //Last bit was received
                                                              if (Bunter==31)
                                                              {
                                                                      Bunter=0;
                                                                      EnableInt1();
                                                                      State = START;
                                                              }
              
                                                              break;
                                                      }
              
                              }
              
              #endif
 196   1      
 197   1      }
*** WARNING C280 IN LINE 126 OF C:\Users\clfilho\Dropbox (Silicon Labs)\Code_Workspace\EFM8UB1_Timer0_8bitReload\src\Int
             -errupts.c: 'counter': unreferenced local variable
*** WARNING C280 IN LINE 127 OF C:\Users\clfilho\Dropbox (Silicon Labs)\Code_Workspace\EFM8UB1_Timer0_8bitReload\src\Int
             -errupts.c: 'buffer': unreferenced local variable
*** WARNING C280 IN LINE 128 OF C:\Users\clfilho\Dropbox (Silicon Labs)\Code_Workspace\EFM8UB1_Timer0_8bitReload\src\Int
             -errupts.c: 'BitBuffer': unreferenced local variable
*** WARNING C280 IN LINE 129 OF C:\Users\clfilho\Dropbox (Silicon Labs)\Code_Workspace\EFM8UB1_Timer0_8bitReload\src\Int
             -errupts.c: 'Bunter': unreferenced local variable
 198          
 199          
 200          
 201          //-----------------------------------------------------------------------------
 202          // INT0_ISR
 203          //-----------------------------------------------------------------------------
 204          //
 205          // TIMER0 ISR Content goes here. Remember to clear flag bits:
 206          // TCON::TF0 (Timer 0 Overflow Flag)
 207          //
 208          // Here we process the Timer0 interrupt and toggle the LED when appropriate
 209          //
 210          //-----------------------------------------------------------------------------
 211          SI_INTERRUPT (INT1_ISR, INT1_IRQn)
 212          {
 213   1         static xdata uint8_t counter = 0;
 214   1      
 215   1      
 216   1         xdata uint16_t timerRead;
 217   1      
 218   1      
 219   1      
 220   1         //Reload Timer
 221   1      
 222   1      
 223   1      #if 1
 224   1      
 225   1              if((GetBusQuietCounter()>3)&&(GetDaliIntputPin()==0) &&(counter==0))
 226   1              {
 227   2                      timerRead = GetDaliRxTimer();
 228   2                      StartDaliRxTimer();
 229   2                      _1stHalf=GetDaliIntputPin();
 230   2                      SetDaliInputPinPolarity(ACTIVE_HIGH);
 231   2              }
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/07/2016 11:34:26 PAGE 5   

 232   1      
 233   1      
 234   1              if (counter++==1)
 235   1              {
 236   2                      _2ndHalf=GetDaliIntputPin();
 237   2                      SetDaliInputPinPolarity(ACTIVE_LOW);
 238   2                      timerRead = GetDaliRxTimer();
 239   2                      //State = DATA;
 240   2                      //counter=0;
 241   2              }
 242   1      
 243   1              if ((_1stHalf==0) && (_2ndHalf==1))                     // Start bit received
 244   1              {
 245   2                      DisableInt1 ();
 246   2                      ReloadDaliTxTimer(TMH, TML);
 247   2                      bitCounter=7;
 248   2                      daliRXOutput=0;
 249   2                      State = DATA;
 250   2                      counter=0;
 251   2                      _1stHalf = _2ndHalf =0;
 252   2                      StopDaliRxTimer();
 253   2      
 254   2              }
 255   1              else if (counter==2)
 256   1              {
 257   2                      counter=0;
 258   2                      _1stHalf = _2ndHalf =0;
 259   2              }
 260   1      
 261   1      #else
              
              
              
                      switch (State)
              
                      {
              
                              case START:                     //In this state, it checks if the RX bus was quit and also if it receives the start bit
                                              {
                                                      if((GetBusQuietCounter()>3)&&(GetDaliIntputPin()==0) &&(counter==0))
                                                      {
                                                              timerRead = GetDaliRxTimer();
                                                              StartDaliRxTimer();
                                                              _1stHalf=GetDaliIntputPin();
                                                              SetDaliInputPinPolarity(ACTIVE_HIGH);
                                                      }
              
              
                                                      if (counter++==1)
                                                      {
                                                              _2ndHalf=GetDaliIntputPin();
                                                              SetDaliInputPinPolarity(ACTIVE_LOW);
                                                              timerRead = GetDaliRxTimer();
                                                              //State = DATA;
                                                              //counter=0;
                                                      }
              
                                                      if ((_1stHalf==0) && (_2ndHalf==1))                     // Start bit received
                                                      {
                                                              DisableInt1 ();
                                                              ReloadDaliTxTimer();
                                                              State = DATA;
                                                              counter=0;
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/07/2016 11:34:26 PAGE 6   

                                                              _1stHalf = _2ndHalf =0;
                                                              StopDaliRxTimer();
              
                                                      }
                                                      else if (counter==2)
                                                      {
                                                              counter=0;
                                                              _1stHalf = _2ndHalf =0;
                                                      }
              
                                                      break;
              
                                              }
              
                              case DATA:
                                              {
              
              #if 0
                                                      if(counter==0)
                                                      {
                                                              timerRead = GetDaliRxTimer();
                                                              StartDaliRxTimer();
                                                              _1stHalf=GetDaliIntputPin();
                                                              if (_1stHalf==1)
                                                              SetDaliInputPinPolarity(ACTIVE_HIGH);
                                                      }
              
              
                                                      if (counter++==1)
                                                      {
                                                              _2ndHalf=GetDaliIntputPin();
                                                              SetDaliInputPinPolarity(ACTIVE_LOW);
                                                              timerRead = GetDaliRxTimer();
                                                              //State = DATA;
                                                              //counter=0;
                                                      }
              
              
              #else
                                                      State = START;
                                                      break;
              #endif
              
              
                      }
              
                      }
              #endif
 343   1      
 344   1      
 345   1      
 346   1      
 347   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    469    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      8      82
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/07/2016 11:34:26 PAGE 7   

   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)
