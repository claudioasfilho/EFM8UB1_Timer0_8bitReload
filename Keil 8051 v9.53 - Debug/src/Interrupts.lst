C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/01/2016 10:23:14 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE INTERRUPTS
OBJECT MODULE PLACED IN .\src\Interrupts.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v3\developer\toolchains\keil_8051\9.53\BIN\C51.exe C:\Users\clfilho
                    -\Dropbox (Silicon Labs)\Code_Workspace\EFM8UB1_Timer0_8bitReload\src\Interrupts.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARG
                    -E) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:\Users\clfilho\
                    -Dropbox (Silicon Labs)\Code_Workspace\EFM8UB1_Timer0_8bitReload\inc;C:/SiliconLabs/SimplicityStudio/v3/developer/sdks/si
                    -8051/v3//Device/shared/si8051Base;C:/SiliconLabs/SimplicityStudio/v3/developer/sdks/si8051/v3//Device/EFM8UB1;C:/Silicon
                    -Labs/SimplicityStudio/v3/developer/sdks/si8051/v3//Device/EFM8UB1/inc) PRINT(.\src\Interrupts.lst) COND PAGEWIDTH(120) P
                    -AGELENGTH(65) OBJECT(.\src\Interrupts.OBJ)

line level    source

   1          //=========================================================
   2          // src/Interrupts.c: generated by Hardware Configurator
   3          //
   4          // This file will be regenerated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!
   7          //=========================================================
   8          
   9                   
  10          // USER INCLUDES                        
  11          #include <SI_EFM8UB1_Register_Enums.h>
  12          #include "InitDevice.h"
  13          
  14          //extern bit MDone;
  15          //extern bit MOutput;
  16          
  17          //-----------------------------------------------------------------------------
  18          // Global Constants
  19          //-----------------------------------------------------------------------------
  20          // Configurator set for HFOSC0/8
  21          #define SYSCLK             3062000
  22          
  23          static xdata DALI_TXFRAME State = START;
  24          static xdata uint8_t bitCounter = 0;
  25          static xdata uint8_t daliRXOutput=0;
  26          bit _1stHalf;
  27          bit _2ndHalf;
  28          
  29          SI_SBIT (LED2,SFR_P1, 4);                          //PB0 Switch Definition
  30          
  31          //-----------------------------------------------------------------------------
  32          // TIMER1_ISR
  33          //-----------------------------------------------------------------------------
  34          //
  35          // TIMER1 ISR Content goes here. Remember to clear flag bits:
  36          // TCON::TF1 (Timer 0 Overflow Flag)
  37          //
  38          // Here we process the Timer dedicated to Dali RX
  39          //
  40          //-----------------------------------------------------------------------------
  41          SI_INTERRUPT (TIMER1_ISR, TIMER1_IRQn)
  42          {
  43   1      
  44   1      static xdata uint8_t counter = 0;
  45   1      xdata uint8_t buffer[8];
  46   1      xdata uint8_t BitBuffer[32];
  47   1      static xdata uint8_t Bunter=0;
  48   1      
  49   1                      ReloadDaliTxTimer(TMH, TML);
  50   1      
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/01/2016 10:23:14 PAGE 2   

  51   1              switch (State)
  52   1      
  53   1                      {
  54   2      
  55   2                              case START:                     //In this state, it checks if the RX bus was quite and also if it receives the start bit
  56   2                                              {
  57   3                                                      break;
  58   3                                              }
  59   2      
  60   2                              case DATA:
  61   2                                              {
  62   3      
  63   3                                                      if(counter==0)
  64   3                                                      {
  65   4                                                              LED2^=1;
  66   4                                                              _1stHalf=GetDaliIntputPin();
  67   4                                                              BitBuffer[Bunter++] = _1stHalf;
  68   4      
  69   4                                                      }
  70   3      
  71   3      
  72   3                                                      if (counter++==1)
  73   3                                                      {       LED2^=1;
  74   4                                                              _2ndHalf=GetDaliIntputPin();
  75   4                                                              BitBuffer[Bunter++] = _2ndHalf;
  76   4      #if 0
                                                                      if ((_1stHalf==0) && (_2ndHalf==1))                     // Logic 1 received
                                                                      {
                                                                              daliRXOutput = bitCounter<<1;
                                                                      }
                                                                      else if ((_1stHalf==1) && (_2ndHalf==0))        // Logic 0 received
                                                                      {
                                                                              daliRXOutput = bitCounter<<0;
                                                                      }
                                                                      else if (_1stHalf ==_2ndHalf)                           // Corrupted bit received
                                                                      {
                                                                              EnableInt1();
                                                                              State = START;
                                                                      }
              #endif
  91   4                                                              counter=0;
  92   4                                                      }
  93   3      
  94   3                                                      buffer[bitCounter] = daliRXOutput;
  95   3      
  96   3                                                      //if (bitCounter--==0)                                                  //Last bit was received
  97   3                                                      if (Bunter==31)
  98   3                                                      {
  99   4                                                              Bunter=0;
 100   4                                                              EnableInt1();
 101   4                                                              State = START;
 102   4                                                      }
 103   3      
 104   3                                                      break;
 105   3                                              }
 106   2      
 107   2                      }
 108   1      
 109   1      
 110   1      }
 111          
 112          
 113          //-----------------------------------------------------------------------------
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/01/2016 10:23:14 PAGE 3   

 114          // TIMER0_ISR
 115          //-----------------------------------------------------------------------------
 116          //
 117          // TIMER0 ISR Content goes here. Remember to clear flag bits:
 118          // TCON::TF0 (Timer 0 Overflow Flag)
 119          //
 120          // Here we process the Timer0 interrupt and toggle the LED when appropriate
 121          //
 122          //-----------------------------------------------------------------------------
 123          SI_INTERRUPT (TIMER0_ISR, TIMER0_IRQn)
 124          {
 125   1         static xdata uint8_t counter = 0;
 126   1         xdata uint8_t buffer[8];
 127   1         xdata uint8_t BitBuffer[32];
 128   1         static xdata uint8_t Bunter=0;
 129   1      
 130   1      
 131   1              ReloadDaliTxTimer(TMH, TML);
 132   1              DaliTxHandler();
 133   1              QueryDaliBus();
 134   1      
 135   1      #if 0
                      switch (State)
              
                              {
              
                                      case START:                     //In this state, it checks if the RX bus was quite and also if it receives the start bit
                                                      {
                                                              break;
                                                      }
              
                                      case DATA:
                                                      {
              
                                                              if(counter==0)
                                                              {
                                                                      LED2^=1;
                                                                      _1stHalf=GetDaliIntputPin();
                                                                      BitBuffer[Bunter++] = _1stHalf;
              
                                                              }
              
              
                                                              if (counter++==1)
                                                              {       LED2^=1;
                                                                      _2ndHalf=GetDaliIntputPin();
                                                                      BitBuffer[Bunter++] = _2ndHalf;
              #if 0
                                                                      if ((_1stHalf==0) && (_2ndHalf==1))                     // Logic 1 received
                                                                      {
                                                                              daliRXOutput = bitCounter<<1;
                                                                      }
                                                                      else if ((_1stHalf==1) && (_2ndHalf==0))        // Logic 0 received
                                                                      {
                                                                              daliRXOutput = bitCounter<<0;
                                                                      }
                                                                      else if (_1stHalf ==_2ndHalf)                           // Corrupted bit received
                                                                      {
                                                                              EnableInt1();
                                                                              State = START;
                                                                      }
              #endif
                                                                      counter=0;
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/01/2016 10:23:14 PAGE 4   

                                                              }
              
                                                              buffer[bitCounter] = daliRXOutput;
              
                                                              //if (bitCounter--==0)                                                  //Last bit was received
                                                              if (Bunter==31)
                                                              {
                                                                      Bunter=0;
                                                                      EnableInt1();
                                                                      State = START;
                                                              }
              
                                                              break;
                                                      }
              
                              }
              
              #endif
 195   1      
 196   1      }
*** WARNING C280 IN LINE 125 OF C:\Users\clfilho\Dropbox (Silicon Labs)\Code_Workspace\EFM8UB1_Timer0_8bitReload\src\Int
             -errupts.c: 'counter': unreferenced local variable
*** WARNING C280 IN LINE 126 OF C:\Users\clfilho\Dropbox (Silicon Labs)\Code_Workspace\EFM8UB1_Timer0_8bitReload\src\Int
             -errupts.c: 'buffer': unreferenced local variable
*** WARNING C280 IN LINE 127 OF C:\Users\clfilho\Dropbox (Silicon Labs)\Code_Workspace\EFM8UB1_Timer0_8bitReload\src\Int
             -errupts.c: 'BitBuffer': unreferenced local variable
*** WARNING C280 IN LINE 128 OF C:\Users\clfilho\Dropbox (Silicon Labs)\Code_Workspace\EFM8UB1_Timer0_8bitReload\src\Int
             -errupts.c: 'Bunter': unreferenced local variable
 197          
 198          
 199          
 200          //-----------------------------------------------------------------------------
 201          // INT0_ISR
 202          //-----------------------------------------------------------------------------
 203          //
 204          // TIMER0 ISR Content goes here. Remember to clear flag bits:
 205          // TCON::TF0 (Timer 0 Overflow Flag)
 206          //
 207          // Here we process the Timer0 interrupt and toggle the LED when appropriate
 208          //
 209          //-----------------------------------------------------------------------------
 210          SI_INTERRUPT (INT1_ISR, INT1_IRQn)
 211          {
 212   1         static xdata uint8_t counter = 0;
 213   1      
 214   1      
 215   1         xdata uint16_t timerRead;
 216   1      
 217   1      
 218   1      
 219   1         //Reload Timer
 220   1      
 221   1      
 222   1      #if 1
 223   1      
 224   1              if((GetBusQuietCounter()>3)&&(GetDaliIntputPin()==0) &&(counter==0))
 225   1              {
 226   2                      timerRead = GetDaliRxTimer();
 227   2                      StartDaliRxTimer();
 228   2                      _1stHalf=GetDaliIntputPin();
 229   2                      SetDaliInputPinPolarity(ACTIVE_HIGH);
 230   2              }
 231   1      
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/01/2016 10:23:14 PAGE 5   

 232   1      
 233   1              if (counter++==1)
 234   1              {
 235   2                      _2ndHalf=GetDaliIntputPin();
 236   2                      SetDaliInputPinPolarity(ACTIVE_LOW);
 237   2                      timerRead = GetDaliRxTimer();
 238   2                      //State = DATA;
 239   2                      //counter=0;
 240   2              }
 241   1      
 242   1              if ((_1stHalf==0) && (_2ndHalf==1))                     // Start bit received
 243   1              {
 244   2                      DisableInt1 ();
 245   2                      ReloadDaliTxTimer(TMH, TML);
 246   2                      bitCounter=7;
 247   2                      daliRXOutput=0;
 248   2                      State = DATA;
 249   2                      counter=0;
 250   2                      _1stHalf = _2ndHalf =0;
 251   2                      StopDaliRxTimer();
 252   2      
 253   2              }
 254   1              else if (counter==2)
 255   1              {
 256   2                      counter=0;
 257   2                      _1stHalf = _2ndHalf =0;
 258   2              }
 259   1      
 260   1      #else
              
              
              
                      switch (State)
              
                      {
              
                              case START:                     //In this state, it checks if the RX bus was quit and also if it receives the start bit
                                              {
                                                      if((GetBusQuietCounter()>3)&&(GetDaliIntputPin()==0) &&(counter==0))
                                                      {
                                                              timerRead = GetDaliRxTimer();
                                                              StartDaliRxTimer();
                                                              _1stHalf=GetDaliIntputPin();
                                                              SetDaliInputPinPolarity(ACTIVE_HIGH);
                                                      }
              
              
                                                      if (counter++==1)
                                                      {
                                                              _2ndHalf=GetDaliIntputPin();
                                                              SetDaliInputPinPolarity(ACTIVE_LOW);
                                                              timerRead = GetDaliRxTimer();
                                                              //State = DATA;
                                                              //counter=0;
                                                      }
              
                                                      if ((_1stHalf==0) && (_2ndHalf==1))                     // Start bit received
                                                      {
                                                              DisableInt1 ();
                                                              ReloadDaliTxTimer();
                                                              State = DATA;
                                                              counter=0;
                                                              _1stHalf = _2ndHalf =0;
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/01/2016 10:23:14 PAGE 6   

                                                              StopDaliRxTimer();
              
                                                      }
                                                      else if (counter==2)
                                                      {
                                                              counter=0;
                                                              _1stHalf = _2ndHalf =0;
                                                      }
              
                                                      break;
              
                                              }
              
                              case DATA:
                                              {
              
              #if 0
                                                      if(counter==0)
                                                      {
                                                              timerRead = GetDaliRxTimer();
                                                              StartDaliRxTimer();
                                                              _1stHalf=GetDaliIntputPin();
                                                              if (_1stHalf==1)
                                                              SetDaliInputPinPolarity(ACTIVE_HIGH);
                                                      }
              
              
                                                      if (counter++==1)
                                                      {
                                                              _2ndHalf=GetDaliIntputPin();
                                                              SetDaliInputPinPolarity(ACTIVE_LOW);
                                                              timerRead = GetDaliRxTimer();
                                                              //State = DATA;
                                                              //counter=0;
                                                      }
              
              
              #else
                                                      State = START;
                                                      break;
              #endif
              
              
                      }
              
                      }
              #endif
 342   1      
 343   1      
 344   1      
 345   1      
 346   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    469    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      8      82
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
   EDATA SIZE       =   ----    ----
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        03/01/2016 10:23:14 PAGE 7   

   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)
