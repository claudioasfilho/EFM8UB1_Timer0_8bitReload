//=========================================================
// src/Interrupts.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================

         
// USER INCLUDES			
#include <SI_EFM8UB1_Register_Enums.h>
#include "InitDevice.h"

//extern bit MDone;
//extern bit MOutput;

//-----------------------------------------------------------------------------
// Global Constants
//-----------------------------------------------------------------------------
// Configurator set for HFOSC0/8
#define SYSCLK             3062000

static xdata DALI_TXFRAME State = START;
static xdata uint8_t bitCounter = 0;
static xdata uint8_t daliRXOutput=0;
bit _1stHalf;
bit _2ndHalf;

SI_SBIT (LED2,SFR_P1, 4);			   //PB0 Switch Definition

//-----------------------------------------------------------------------------
// TIMER1_ISR
//-----------------------------------------------------------------------------
//
// TIMER1 ISR Content goes here. Remember to clear flag bits:
// TCON::TF1 (Timer 0 Overflow Flag)
//
// Here we process the Timer dedicated to Dali RX
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (TIMER1_ISR, TIMER1_IRQn)
{

static xdata uint8_t counter = 0;
xdata uint8_t buffer[8];
xdata uint8_t BitBuffer[32];
static xdata uint8_t Bunter=0;

		ReloadDaliTxTimer(TMH, TML);

	switch (State)

		{

			case START:			//In this state, it checks if the RX bus was quite and also if it receives the start bit
					{
						break;
					}

			case DATA:
					{

						if(counter==0)
						{
							LED2^=1;
							_1stHalf=GetDaliIntputPin();
							BitBuffer[Bunter++] = _1stHalf;

						}


						if (counter++==1)
						{	LED2^=1;
							_2ndHalf=GetDaliIntputPin();
							BitBuffer[Bunter++] = _2ndHalf;
#if 0
							if ((_1stHalf==0) && (_2ndHalf==1))			// Logic 1 received
							{
								daliRXOutput = bitCounter<<1;
							}
							else if ((_1stHalf==1) && (_2ndHalf==0))	// Logic 0 received
							{
								daliRXOutput = bitCounter<<0;
							}
							else if (_1stHalf ==_2ndHalf)				// Corrupted bit received
							{
								EnableInt1();
								State = START;
							}
#endif
							counter=0;
						}

						buffer[bitCounter] = daliRXOutput;

						//if (bitCounter--==0)							//Last bit was received
						if (Bunter==31)
						{
							Bunter=0;
							EnableInt1();
							State = START;
						}

						break;
					}

		}


}


//-----------------------------------------------------------------------------
// TIMER0_ISR
//-----------------------------------------------------------------------------
//
// TIMER0 ISR Content goes here. Remember to clear flag bits:
// TCON::TF0 (Timer 0 Overflow Flag)
//
// Here we process the Timer0 interrupt and toggle the LED when appropriate
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (TIMER0_ISR, TIMER0_IRQn)
{
   static xdata uint8_t counter = 0;
   xdata uint8_t buffer[8];
   xdata uint8_t BitBuffer[32];
   static xdata uint8_t Bunter=0;


	ReloadDaliTxTimer(TMH, TML);
	DaliTxHandler();
	QueryDaliBus();

#if 0
	switch (State)

		{

			case START:			//In this state, it checks if the RX bus was quite and also if it receives the start bit
					{
						break;
					}

			case DATA:
					{

						if(counter==0)
						{
							LED2^=1;
							_1stHalf=GetDaliIntputPin();
							BitBuffer[Bunter++] = _1stHalf;

						}


						if (counter++==1)
						{	LED2^=1;
							_2ndHalf=GetDaliIntputPin();
							BitBuffer[Bunter++] = _2ndHalf;
#if 0
							if ((_1stHalf==0) && (_2ndHalf==1))			// Logic 1 received
							{
								daliRXOutput = bitCounter<<1;
							}
							else if ((_1stHalf==1) && (_2ndHalf==0))	// Logic 0 received
							{
								daliRXOutput = bitCounter<<0;
							}
							else if (_1stHalf ==_2ndHalf)				// Corrupted bit received
							{
								EnableInt1();
								State = START;
							}
#endif
							counter=0;
						}

						buffer[bitCounter] = daliRXOutput;

						//if (bitCounter--==0)							//Last bit was received
						if (Bunter==31)
						{
							Bunter=0;
							EnableInt1();
							State = START;
						}

						break;
					}

		}

#endif

}



//-----------------------------------------------------------------------------
// INT0_ISR
//-----------------------------------------------------------------------------
//
// TIMER0 ISR Content goes here. Remember to clear flag bits:
// TCON::TF0 (Timer 0 Overflow Flag)
//
// Here we process the Timer0 interrupt and toggle the LED when appropriate
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (INT1_ISR, INT1_IRQn)
{
   static xdata uint8_t counter = 0;


   xdata uint16_t timerRead;



   //Reload Timer


#if 1

	if((GetBusQuietCounter()>3)&&(GetDaliIntputPin()==0) &&(counter==0))
	{
		timerRead = GetDaliRxTimer();
		StartDaliRxTimer();
		_1stHalf=GetDaliIntputPin();
		SetDaliInputPinPolarity(ACTIVE_HIGH);
	}


	if (counter++==1)
	{
		_2ndHalf=GetDaliIntputPin();
		SetDaliInputPinPolarity(ACTIVE_LOW);
		timerRead = GetDaliRxTimer();
		//State = DATA;
		//counter=0;
	}

	if ((_1stHalf==0) && (_2ndHalf==1))			// Start bit received
	{
		DisableInt1 ();
		ReloadDaliTxTimer(TMH, TML);
		bitCounter=7;
		daliRXOutput=0;
		State = DATA;
		counter=0;
		_1stHalf = _2ndHalf =0;
		StopDaliRxTimer();

	}
	else if (counter==2)
	{
		counter=0;
		_1stHalf = _2ndHalf =0;
	}

#else



	switch (State)

	{

		case START:			//In this state, it checks if the RX bus was quit and also if it receives the start bit
				{
					if((GetBusQuietCounter()>3)&&(GetDaliIntputPin()==0) &&(counter==0))
					{
						timerRead = GetDaliRxTimer();
						StartDaliRxTimer();
						_1stHalf=GetDaliIntputPin();
						SetDaliInputPinPolarity(ACTIVE_HIGH);
					}


					if (counter++==1)
					{
						_2ndHalf=GetDaliIntputPin();
						SetDaliInputPinPolarity(ACTIVE_LOW);
						timerRead = GetDaliRxTimer();
						//State = DATA;
						//counter=0;
					}

					if ((_1stHalf==0) && (_2ndHalf==1))			// Start bit received
					{
						DisableInt1 ();
						ReloadDaliTxTimer();
						State = DATA;
						counter=0;
						_1stHalf = _2ndHalf =0;
						StopDaliRxTimer();

					}
					else if (counter==2)
					{
						counter=0;
						_1stHalf = _2ndHalf =0;
					}

					break;

				}

		case DATA:
				{

#if 0
					if(counter==0)
					{
						timerRead = GetDaliRxTimer();
						StartDaliRxTimer();
						_1stHalf=GetDaliIntputPin();
						if (_1stHalf==1)
						SetDaliInputPinPolarity(ACTIVE_HIGH);
					}


					if (counter++==1)
					{
						_2ndHalf=GetDaliIntputPin();
						SetDaliInputPinPolarity(ACTIVE_LOW);
						timerRead = GetDaliRxTimer();
						//State = DATA;
						//counter=0;
					}


#else
					State = START;
					break;
#endif


	}

	}
#endif




}
